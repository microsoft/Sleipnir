# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

"""Used as entry point when Sleipnir is invoked."""

# ruff: noqa: F401 I001 # slp_logger needs to be imported before any other modules

import argparse
import logging
import os
import pathlib

import slp_logger as logger
import slp_dwarf_parser as dp
import slp_preprocessor as pp
import slp_utils as utils

if not os.getenv("ELF_PATH"):
    msg = "ELF_PATH environment variable not set."
    raise OSError(msg)

ELF_PATH_FRAME = pathlib.Path().joinpath(os.getenv("ELF_PATH"), "frame.elf")
"""Path to the ELF file that contains the DWARF information for the data types."""

# Check if Sleipnir's dependencies have been generated first
if not ELF_PATH_FRAME.exists():
    msg = f"{ELF_PATH_FRAME} does not exist... please generate it first."
    raise FileNotFoundError(msg)


def main(input_yml: str, output_yml: str) -> None:
    """Entry function."""
    suite = pp.process_in_yaml(input_yml)

    dwarfs_frame = dp.parse_dwarf_from_elf(ELF_PATH_FRAME)

    # Parse enums and datatypes in ELF
    dp.enm = dp.BfEnums(dwarfs_frame["enums"])
    dp.types = dwarfs_frame["types"]

    for test in suite["test"]:
        if (not test["params"]) or (not test["params"].get("sleipnir", False)):
            logging.info("'sleipnir' key not found in params for test id %s", test["id"])
            continue

        params = test["params"]

        # ----------------------------------------------------------------------
        # Generate random data
        # ----------------------------------------------------------------------
        utils.gen_data(test)

        # ----------------------------------------------------------------------
        # Generate random frames
        # ----------------------------------------------------------------------
        utils.gen_frames(test)

        # ----------------------------------------------------------------------
        # Delete the sleipnir params entry before writing it out
        # ----------------------------------------------------------------------
        del params["sleipnir"]

    # Write the updated suite.yml back
    with pathlib.Path(output_yml).open(mode="w") as output_file:
        pp.yaml.dump(suite, output_file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Invoke Sleipnir with the input yml to generate the outputs."
    )
    parser.add_argument(
        "input_yml",
        type=str,
        metavar="<input yml>",
        help="path to the input yml",
    )
    parser.add_argument(
        "output_yml",
        type=str,
        metavar="<output yml>",
        help="path to the output yml which is generated by Sleipnir",
    )

    args = parser.parse_args()
    main(args.input_yml, args.output_yml)
